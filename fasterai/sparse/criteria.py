# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/0b_criteria.ipynb (unless otherwise specified).

__all__ = ['random', 'large_final', 'small_final', 'large_init', 'small_init', 'large_init_large_final',
           'small_init_small_final', 'magnitude_increase', 'movement', 'updating_magnitude_increase', 'grad_crit']

# Cell
import torch
import torch.nn as nn
import torch.nn.functional as F

# Cell
def random(m, granularity):

    if granularity == 'weight':
        w = torch.randn(m.weight.shape)

    elif granularity == 'vector':
        dim = 3 # dim=1 -> channel vector, dim=2 -> column vector, dim=3 -> row vector
        w = torch.randn(m.weight.shape).mean(dim=dim, keepdim=True)

    elif granularity == 'kernel':
        w = torch.randn(m.weight.shape).mean(dim=(2,3), keepdim=True)

    elif granularity == 'filter':
        w = torch.randn(m.weight.shape).mean(dim=(1,2,3), keepdim=True)

    else: raise NameError('Invalid Granularity')

    return w

# Cell
def large_final(m, granularity):

    if granularity == 'weight':
        w = m.weight.abs()

    elif granularity == 'vector':
        dim = 3 # dim=1 -> channel vector, dim=2 -> column vector, dim=3 -> row vector
        w = m.weight.abs().mean(dim=dim, keepdim=True)

    elif granularity == 'kernel':
        w = m.weight.abs().mean(dim=(2,3), keepdim=True)

    elif granularity == 'filter':
        w = m.weight.abs().mean(dim=(1,2,3), keepdim=True)

    else: raise NameError('Invalid Granularity')

    return w

# Cell
def small_final(m, granularity):

    if granularity == 'weight':
        w = -m.weight.abs()

    elif granularity == 'vector':
        dim = 3 # dim=1 -> channel vector, dim=2 -> column vector, dim=3 -> row vector
        w = -m.weight.abs().mean(dim=dim, keepdim=True)

    elif granularity == 'kernel':
        w = -m.weight.abs().mean(dim=(2,3), keepdim=True)

    elif granularity == 'filter':
        w = -m.weight.abs().mean(dim=(1,2,3), keepdim=True)

    else: raise NameError('Invalid Granularity')

    return w

# Cell
def large_init(m, granularity):

    if granularity == 'weight':
        w = m._init_weights.abs()

    elif granularity == 'vector':
        dim = 3 # dim=1 -> channel vector, dim=2 -> column vector, dim=3 -> row vector
        w = m._init_weights.abs().mean(dim=dim, keepdim=True)

    elif granularity == 'kernel':
        w = m._init_weights.abs().mean(dim=(2,3), keepdim=True)

    elif granularity == 'filter':
        w = m._init_weights.abs().mean(dim=(1,2,3), keepdim=True)

    else: raise NameError('Invalid Granularity')

    return w

# Cell
def small_init(m, granularity):

    if granularity == 'weight':
        w = -m._init_weights.abs()

    elif granularity == 'vector':
        dim = 3 # dim=1 -> channel vector, dim=2 -> column vector, dim=3 -> row vector
        w = -m._init_weights.abs().mean(dim=dim, keepdim=True)

    elif granularity == 'kernel':
        w = -m._init_weights.abs().mean(dim=(2,3), keepdim=True)

    elif granularity == 'filter':
        w = -m._init_weights.abs().mean(dim=(1,2,3), keepdim=True)

    else: raise NameError('Invalid Granularity')

    return w

# Cell
def large_init_large_final(m, granularity):

    if granularity == 'weight':
        wi = m._init_weights.abs()
        wf = m.weight.abs()

    elif granularity == 'vector':
        dim = 3 # dim=1 -> channel vector, dim=2 -> column vector, dim=3 -> row vector
        wi = m._init_weights.abs().mean(dim=dim, keepdim=True)
        wf = m.weight.abs().mean(dim=dim, keepdim=True)

    elif granularity == 'kernel':
        wi = m._init_weights.abs().mean(dim=(2,3), keepdim=True)
        wf = m.weight.abs().mean(dim=(2,3), keepdim=True)

    elif granularity == 'filter':
        wi = m._init_weights.abs().mean(dim=(1,2,3), keepdim=True)
        wf = m.weight.abs().mean(dim=(1,2,3), keepdim=True)

    else: raise NameError('Invalid Granularity')

    return torch.min(torch.stack([wi,wf]), dim=0)[0]

# Cell
def small_init_small_final(m, granularity):

    if granularity == 'weight':
        wi = m._init_weights.abs()
        wf = m.weight.abs()

    elif granularity == 'vector':
        dim = 3 # dim=1 -> channel vector, dim=2 -> column vector, dim=3 -> row vector
        wi = m._init_weights.abs().mean(dim=dim, keepdim=True)
        wf = m.weight.abs().mean(dim=dim, keepdim=True)

    elif granularity == 'kernel':
        wi = m._init_weights.abs().mean(dim=(2,3), keepdim=True)
        wf = m.weight.abs().mean(dim=(2,3), keepdim=True)

    elif granularity == 'filter':
        wi = m._init_weights.abs().mean(dim=(1,2,3), keepdim=True)
        wf = m.weight.abs().mean(dim=(1,2,3), keepdim=True)

    else: raise NameError('Invalid Granularity')

    return -torch.max(torch.stack([wi,wf]), dim=0)[0]

# Cell
def magnitude_increase(m, granularity):

    if granularity == 'weight':
        wi = m._init_weights.abs()
        wf = m.weight.abs()

    elif granularity == 'vector':
        dim = 3 # dim=1 -> channel vector, dim=2 -> column vector, dim=3 -> row vector
        wi = m._init_weights.abs().mean(dim=dim, keepdim=True)
        wf = m.weight.abs().mean(dim=dim, keepdim=True)

    elif granularity == 'kernel':
        wi = m._init_weights.abs().mean(dim=(2,3), keepdim=True)
        wf = m.weight.abs().mean(dim=(2,3), keepdim=True)

    elif granularity == 'filter':
        wi = m._init_weights.abs().mean(dim=(1,2,3), keepdim=True)
        wf = m.weight.abs().mean(dim=(1,2,3), keepdim=True)

    else: raise NameError('Invalid Granularity')

    return wf-wi

# Cell
def movement(m, granularity):

    if granularity == 'weight':
        wi = m._init_weights
        wf = m.weight

    elif granularity == 'vector':
        dim = 3 # dim=1 -> channel vector, dim=2 -> column vector, dim=3 -> row vector
        wi = m._init_weights.mean(dim=dim, keepdim=True)
        wf = m.weight.mean(dim=dim, keepdim=True)

    elif granularity == 'kernel':
        wi = m._init_weights.mean(dim=(2,3), keepdim=True)
        wf = m.weight.mean(dim=(2,3), keepdim=True)

    elif granularity == 'filter':
        wi = m._init_weights.mean(dim=(1,2,3), keepdim=True)
        wf = m.weight.mean(dim=(1,2,3), keepdim=True)

    else: raise NameError('Invalid Granularity')

    return abs(wf-wi)

# Cell
def updating_magnitude_increase(m, granularity):
    # This implementation updates the value of init_weight to compare to the last iteration
    if hasattr(m, '_old_weights') == False:
        m.register_buffer("_old_weights", m._init_weights.clone()) # If the previous value of weights is not known, take the initial value

    if granularity == 'weight':
        wf = m.weight.abs()
        wi = m._old_weights.abs()
    elif granularity == 'vector':
        dim = 3
        wi = m._old_weights.abs().mean(dim=dim, keepdim=True)
        wf = m.weight.abs().mean(dim=dim, keepdim=True)

    elif granularity == 'kernel':
        wi = m._old_weights.abs().mean(dim=(2,3), keepdim=True)
        wf = m.weight.abs().mean(dim=(2,3), keepdim=True)

    elif granularity == 'filter':
        wi = m._old_weights.abs().mean(dim=(1,2,3), keepdim=True)
        wf = m.weight.abs().mean(dim=(1,2,3), keepdim=True)

    m._old_weights = m.weight.clone() # The current value becomes the old one for the next iteration

    return wf-wi

# Cell
def grad_crit(m, granularity):
    if m.weight.grad is not None:
        if granularity == 'weight':
            w = (m.weight*m.weight.grad).pow(2)

        elif granularity == 'vector':
            w = (m.weight*m.weight.grad).pow(2).mean(dim=dim, keepdim=True)

        elif granularity == 'kernel':
            w = (m.weight*m.weight.grad).pow(2).mean(dim=(2,3), keepdim=True)

        elif granularity == 'filter':
            w = (m.weight*m.weight.grad).pow(2).mean(dim=(1,2,3), keepdim=True)

        else: raise NameError('Invalid Granularity')

        return w